#!/usr/bin/perl
use 5.001 ; use strict ; use warnings ; 
use Getopt::Std ; getopts ':~1' , \my %o ; 
use autodie qw[ open ] ; 

unshift @ARGV  , splice @ARGV , 1 , 1 if $o{'~'} ; # 条件次第で先頭とその次を入れ替える。
#print join "," , @ARGV ; exit 2 ; 
open my $FH , '<' , shift @ARGV ; 
$SIG{ INT } = sub { close $FH ; exit 130 } ; 
my %seen ; 

unless ( $o{1} ) { 
	while ( <$FH> ) { 
	    chomp ; 
	    $seen { $_ }  = $. ; 
	}
} else { 
	while ( <$FH> ) { 
	    chomp ; 
	    $seen { $_ }  = $. unless exists $seen { $_ } ;
	}
}


close $FH ; 

while ( <> ) { 
    chomp ; 
    delete $seen { $_ } if exists $seen { $_ } ; 
}


unless ( $o{':'} ) { 
	print "$_\n" for ( sort keys %seen ) ; 
} else { 
	print "$_\t$seen{$_}\n" for ( sort { $seen{$a} <=> $seen{$b} } keys %seen ) ; 
}

=encoding utf8
=head1
  $0 file1 file2 
  $0 file1 < file2 
  cat file2 | $0 file1 

  file1 のどこかの行にあって、file2 にないものを抽出する。
  メモリの消費は、file1の各行の異なる行の数に応じたものになる。

 オプション : 

  -~  : file1 と file2 の順序を交換する。
  -:  : 出力の際に、各要素が最後に何行目に現れたかを出力する。
  -1  ; 出力の際に、何行目に現れたについて、最後ではなくて最初の行の番号を出力。-: と共に用いる。

=cut

## ヘルプの扱い
sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
    use FindBin qw[ $Script ] ; 
    $ARGV[1] //= '' ;
    open my $FH , '<' , $0 ;
    while(<$FH>){
        s/\$0/$Script/g ;
        print $_ if s/^=head1// .. s/^=cut// and $ARGV[1] =~ /^o(p(t(i(o(ns?)?)?)?)?)?$/i ? m/^\s+\-/ : 1;
    }
    close $FH ;
    exit 0 ;
}



