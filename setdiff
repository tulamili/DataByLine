#!/usr/bin/perl
use 5.001 ; use strict ; use warnings ; 
use Getopt::Std ; getopts ':~' , \my %o ; 
use autodie qw[ open ] ; 

unshift @ARGV  , splice @ARGV , 1 , 1 if $o{'~'} ; # 条件次第で先頭とその次を入れ替える。
#print join "," , @ARGV ; exit 2 ; 
open my $FH , '<' , shift @ARGV ; 
$SIG{ INT } = sub { close $FH ; exit 130 } ; 
my %lastseen ; 

while ( <$FH> ) { 
    chomp ; 
    $lastseen { $_ }  = $. ; 
}

close $FH ; 

while ( <> ) { 
    chomp ; 
    delete $lastseen { $_ } if exists $lastseen { $_ } ; 
}


unless ( $o{':'} ) { 
	print "$_\n" for ( keys %lastseen ) ; 
} else { 
	print "$_\t$lastseen{$_}\n" for ( keys %lastseen ) ; 
}

=encoding utf8
=head1
  $0 file1 file2 
  $0 file1 < file2 
  cat file2 | $0 file1 

  file1 のどこかの行にあって、file2 にないものを抽出する。
  メモリの消費は、file1の各行の異なる行の数に応じたものになる。

 オプション : 

  -~  : file1 と file2 の順序を交換する。
  -:  : 出力の際に、各要素が最後に何行目に現れたかを出力する。

=cut

## ヘルプの扱い
sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
    use FindBin qw[ $Script ] ; 
    $ARGV[1] //= '' ;
    open my $FH , '<' , $0 ;
    while(<$FH>){
        s/\$0/$Script/g ;
        print $_ if s/^=head1// .. s/^=cut// and $ARGV[1] =~ /^o(p(t(i(o(ns?)?)?)?)?)?$/i ? m/^\s+\-/ : 1;
    }
    close $FH ;
    exit 0 ;
}



